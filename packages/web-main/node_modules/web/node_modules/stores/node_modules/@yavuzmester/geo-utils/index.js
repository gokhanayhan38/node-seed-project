"use strict";

const degreesToRadians = require("degrees-radians");
const radiansToDegrees = require("radians-degrees");

const geoUtils = {
    /**
     * Ref: https://blogs.bing.com/maps/2006/02/25/map-control-zoom-levels-gt-resolution/
     *
     * Another resource: http://wiki.openstreetmap.org/wiki/Zoom_levels
     *      "Metres per pixel math" section
     */
    calculatePixelArea: function({lat /*: number */, zoom /*: number */}) /*: number */ /*in meter squares*/ {
        if (Number.isFinite(lat) && Number.isFinite(zoom)) {
            const latInRadians = degreesToRadians(lat);
            return Math.round(156543.04 * Math.cos(latInRadians) / Math.pow(2, zoom));
        }
    },

    /**
     * Ref: http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
     */
    latLngToTile: function({latLng /*: object */, zoom /*: number */}) {
        if (latLng && Number.isFinite(latLng.lat) && Number.isFinite(latLng.lng) && Number.isFinite(zoom)) {
            const {lat, lng} = latLng;

            const numOfTilesOnAnAxis = Math.pow(2, zoom),
                LNG_MAX = 180 - 1e-6,
                LNG_MIN = -LNG_MAX,
                LAT_MAX = 85.0511,
                LAT_MIN = -LAT_MAX;

            //clip lat & lng
            const latClipped = Math.min(LAT_MAX, Math.max(LAT_MIN, lat)),
                lngClipped = Math.min(LNG_MAX, Math.max(LNG_MIN, lng));

            const latInRadians = degreesToRadians(latClipped);

            //conversion
            const x = Math.floor(numOfTilesOnAnAxis * ((lngClipped + 180) / 360));
            const y = Math.floor(numOfTilesOnAnAxis * (1 - (Math.log(Math.tan(latInRadians) + 1 / Math.cos(latInRadians)) / Math.PI)) / 2);

            return {x, y, zoom};
        }
    },

    tileToLatLng: function({x /*: number */, y /*: number */, zoom /*: number */}) /*: object */ {
        if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(zoom)) {
            const numOfTilesOnAnAxis = Math.pow(2, zoom),
                tileCenterX = x + 0.5,
                tileCenterY = y + 0.5;

            const lng = tileCenterX / numOfTilesOnAnAxis * 360.0 - 180.0;

            const latInRadians = Math.atan(Math.sinh(Math.PI * (1 - 2 * tileCenterY / numOfTilesOnAnAxis)));
            const lat = radiansToDegrees(latInRadians);

            return {lat: lat, lng: lng, zoom: zoom};
        }
    },

    tileFlipY: function({x /*: number */, y /*: number */, zoom /*: number */}) {
        return {
            x: x,
            y: Math.pow(2, zoom) - 1 - y,
            zoom: zoom
        };
    },

    validateLatLng: function(obj={} /* ?object */) /*: boolean */ {
        const {lat /*: number */, lng /*: number */} = obj || {};

        if (!Number.isFinite(lat) || lat < -90 || lat > 90) {
            return false;
        }
        else if (!Number.isFinite(lng) || lng < -180 || lng > 180) {
            return false;
        }
        else {
            return true;
        }
    },

    validateTile: function(obj={} /* ?object */) /*: boolean */ {
        const {x /*: number */, y /*: number */, zoom /*: number */} = obj || {};

        if (!Number.isFinite(zoom) || zoom < 0 || zoom > 17) {
            return false;
        }
        else if (!Number.isFinite(x) || x < 0 || x >= Math.pow(2, zoom)) {
            return false;
        }
        else if (!Number.isFinite(y) || y < 0 || x >= Math.pow(2, zoom)) {
            return false;
        }
        else {
            return true;
        }
    }
};

module.exports = geoUtils;
