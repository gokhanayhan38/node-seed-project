"use strict";

const fetch = require("node-fetch");
const msgpack = require("msgpack-lite");

const cacheKeys = {};

const fetchHelpers = {
    get: function({path /*: string */, origin="" /*: ?string */, reload=false /*: ?boolean */, timeout=2000 /*: ?number */,
                   responseType="json" /*: ?string */, useMessagePack=false /*: ?boolean */})
        /*: object */ /*promise*/ {

        const shouldReload = !cacheKeys[path] ? true : reload;
        const cacheKey = !shouldReload ? cacheKeys[path] : new Date().getTime();

        return fetch(
            `${origin}${path}${path.indexOf("?") < 0 ? "?" : "&"}_=${cacheKey}`,
            {timeout: timeout}
        ).then(response => {
            if (shouldReload) {
                cacheKeys[path] = cacheKey;
            }

            return resolveResponse({response, responseType, useMessagePack});
        });
    },

    post: function({path /*: string */, body /*: object */, origin="" /*: ?string */, timeout=2000 /*: ?number */,
                    responseType="json" /*: ?string */}) /*: object */ /*promise*/ {

        return fetch(
            `${origin}/${path}`,
            {
                method: "POST",
                body: JSON.stringify(body),
                timeout: timeout
            }
        ).then(response => {
            return resolveResponse({response, responseType});
        });
    }
};

function resolveResponse({response /*: object */, responseType /*: string */, useMessagePack=false /*: ?boolean */}) /*: object | string */ {
    switch(responseType) {
        case "json":
            return response.json();
        case "text":
            return response.text();
        case "buffer":
            return response.buffer().then(buffer => {
                return !useMessagePack ? buffer : msgpack.decode(buffer);
            });
    }
}

module.exports = fetchHelpers;
